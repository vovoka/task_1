from os import urandom
import requests as urlrequest 
from urllib.parse import urlparse
from lib.database import Database
from flask import Flask, render_template, request, jsonify, redirect, abort

class Webserver:

    def __init__(self):
        self.database = Database()
        self.app = Flask(__name__)
        self.app.secret_key = urandom(0x200)

    @property
    def server_url(self) ->str:
        """ Return string with the server URL (for example 'http://mysite.com')"""
        parse = urlparse(request.url)
        return '{}://{}/'.format(parse.scheme, parse.netloc)

    def add_paths(self) -> None:
        self.app.add_url_rule('/', 'index', self.index, defaults={'link_id': ''})
        self.app.add_url_rule('/<path:link_id>', 'index', self.index)
        self.app.add_url_rule('/create', 'create', self.create, methods=['POST'])


    def index(self, link_id):
        """ Render index.html page """
        print('CALL def index')
        if link_id:
            print(f'requested  link_id = {link_id}')

            # handle (redirect) requests http://domain_name/link_id
            # to address contained link_url via DB data
            if self.database.link_id_exists(link_id):
                url = self.database.get_link_url(link_id)
                return redirect(url)
            # i.e. the ULR (you are trying to access) does not exist.
            return abort(404)

        return render_template('index.html')


    def is_internal_url(self, url:str) ->bool:
        """ Checks URL value if it's belong the urlshortener """
        parse = urlparse(url)

        link1 = '{}://{}{}{}{}{}'.format(
            'https' if not parse.scheme else parse.scheme, 
            parse.netloc.lower(), 
            parse.path, 
            parse.params, 
            '?' + parse.query if parse.query else '', 
            parse.fragment
        )

        link2 = link1.replace('https', 'http') 

        try:
            urlrequest.get(link1)
            link = link1
        except:
            link = link2

        print(f'CALLED Parser. Return:{not bool((parse.netloc or parse.path) and urlparse(request.url).netloc != parse.netloc)} ')

        return (not (parse.netloc or parse.path) and urlparse(request.url).netloc != parse.netloc)


    def get_link_id(self, link_url: str) ->str:
        """ Return link_id from DB"""
        url = urlparse(request.url).netloc
        link_id = self.database.generate_link_id(url)
        
        self.database.add_link(link_url, link_id)
        return link_id

    def create(self) -> str:
        """ Returns serialized json with a new value of input form """
        if not 'link' in request.form:
            print('1 FIRST CASE !!!')
            return jsonify({ 'resp': '' })

        # when receive some URL from the form:
        link_url = request.form['link']

        # if the URL belongs to one of generated by the urlshortener
        if self.is_internal_url(link_url):
            print('2 INTERNAL LINK!!!')
            link_url = ''

        if not link_url:
            print('3 THIS CASE!!!')
            return jsonify({ 'resp': '' })


        # VK explorations
        print(f'link_url = {link_url}')

        # response with generated link
        link_id = self.get_link_id(link_url)
        return jsonify({ 'resp': self.server_url + link_id})

    def start(self) -> None:
        self.add_paths()
        self.database.start()
        # self.app.run(debug=False)
        self.app.run(debug=True)

if __name__ == '__main__':
    webserver = Webserver()
    webserver.start()